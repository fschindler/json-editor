import{isParentNode}from"../types";import{invalidPathError,invalidNodeTypeError}from"../errors";import{getChildNodeIndex}from"../node/getChildNode";import{split,join}from"gson-pointer";export function buildPathsMap(e){const r={};return e.forEach((e=>{const t=split(e);let o=r;for(let e=0,r=t.length;e<r;e+=1){const r=t[e];o[r]=o[r]||{},o=o[r]}o.$return=!0})),r}export function unlinkMap(e,r){throw new Error("not implemented")}export function unlinkPaths(e,r){throw new Error("not implemented")}export function unlinkPath(e,r){if(r=join(r),!isParentNode(e))return invalidNodeTypeError({pointer:r,expectedType:"array or object",type:null==e?void 0:e.type,reason:"root node must be of type array or object or else there is nothing to delete",where:`transform: 'remove' data at '${r}'`});const t=split(r),o={...e};let n,i=o,a=-1;for(;t.length>0;){if(n=t.shift(),a=getChildNodeIndex(i,n),!isParentNode(i)||a<0)return invalidPathError({pointer:r,reason:`path does not lead to valid destination in data/tree at ${i.pointer}`,where:`transform: 'remove' data at '${r}'`});const e={...i.children[a]};i.children=[...i.children],i.children[a]=e,i=e}return[o,i]}